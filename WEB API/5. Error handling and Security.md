# ==Response status codes

Here's a clear breakdown of HTTP status codes and their importance when working with APIs:

### HTTP Status Codes Explained

#### The 4 Main Categories of Status Codes:

1. **200s (Success)**
   - `200 OK`: The request succeeded
   - `201 Created`: New resource was created
   - `204 No Content`: Success but no content to return
   - *What it means*: Your request worked exactly as expected

2. **300s (Redirection)**
   - `301 Moved Permanently`: Resource has a new permanent URL
   - `304 Not Modified`: Cached version is still valid
   - *What it means*: The request needs follow-up action

3. **400s (Client Errors)**
   - `400 Bad Request`: Malformed request syntax
   - `401 Unauthorized`: Authentication failed
   - `403 Forbidden`: No permission to access
   - `404 Not Found`: Resource doesn't exist
   - *What it means*: You made a mistake in your request

4. **500s (Server Errors)**
   - `500 Internal Server Error`: Generic server failure
   - `503 Service Unavailable`: Server is overloaded
   - *What it means*: The API server has problems

#### Practical Examples from the Transcript:

1. **Successful Request (200)**
   ```javascript
   // Correct API request
   fetch('https://api.giphy.com/v1/gifs/random?api_key=...')
     .then(response => {
       console.log(response.status); // 200
       return response.json();
     })
   ```

2. **Failed Request (404)**
   ```javascript
   // Incorrect endpoint (extra 'm')
   fetch('https://api.giphy.com/v1/gifs/randomm?api_key=...')
     .then(response => {
       console.log(response.status); // 404
       return response.json();
     })
   ```

#### Key Takeaways:

1. **Always check status codes** in your API responses
2. **200s mean success**, while 400s/500s indicate problems
3. **Use tools like Postman** to test endpoints and view status codes
4. **Check the response meta object** for detailed error messages
5. **Common mistakes** that cause errors:
   - Typos in endpoints (404)
   - Missing parameters (400)
   - Invalid API keys (401)
   - Server issues (500)

#### Pro Tip:
Handle different status codes in your code:
```javascript
fetch(apiUrl)
  .then(response => {
    if (!response.ok) { // Checks for 400-599 status codes
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response.json();
  })
  .catch(error => {
    console.error('API request failed:', error);
    // Show user-friendly error message
  });
```

Understanding these status codes will help you quickly debug API issues and build more robust applications.

---


# ==How to handle errors

### API Error Handling Best Practices

#### 1. Basic Error Handling Structure
```javascript
fetch('https://api.example.com/data')
  .then(response => {
    if (!response.ok) { // Checks for 4xx-5xx status
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response.json();
  })
  .then(data => {
    // Process successful response
    displayData(data);
  })
  .catch(error => {
    // Handle network errors or thrown exceptions
    showErrorToUser(error.message);
  });
```

#### 2. Status Code Handling
- **200-299**: Success (use `response.ok` or check specific codes)
- **400-499**: Client errors (fix your request)
- **500-599**: Server errors (try again later)

#### 3. Common Error Scenarios & Solutions

**Scenario 1: API Endpoint Not Found (404)**
```javascript
if (response.status === 404) {
  throw new Error('The requested resource was not found');
}
```

**Scenario 2: Authentication Failed (401)**
```javascript
if (response.status === 401) {
  redirectToLogin();
  return; // Exit the chain
}
```

**Scenario 3: Invalid Data Structure**
```javascript
.then(data => {
  if (!data || !data.images || !data.images.original) {
    throw new Error('Invalid data structure from API');
  }
  return data;
})
```

#### 4. User-Friendly Error Handling
```javascript
function showErrorToUser(error) {
  const errorElement = document.createElement('div');
  errorElement.className = 'error-message';
  
  // Custom messages for different errors
  const message = error.includes('404') ? 'Content not found' :
                 error.includes('network') ? 'Network problem' :
                 'Something went wrong';
  
  errorElement.textContent = `⚠️ ${message}. Please try again.`;
  document.body.prepend(errorElement);
}
```

#### 5. Complete Example with UI Integration
```javascript
async function fetchGif() {
  try {
    const response = await fetch('https://api.giphy.com/v1/gifs/random?api_key=YOUR_KEY');
    
    if (!response.ok) {
      throw new Error(`API Error: ${response.status}`);
    }
    
    const data = await response.json();
    
    if (!data?.data?.images?.original?.url) {
      throw new Error('Invalid GIF data structure');
    }
    
    displayGif(data.data);
  } catch (error) {
    showError(error.message);
    console.error('Fetch failed:', error);
  }
}

function displayGif(gifData) {
  document.getElementById('gif-container').innerHTML = `
    <img src="${gifData.images.original.url}" alt="${gifData.title}">
    <h3>${gifData.title}</h3>
  `;
}

function showError(message) {
  document.getElementById('error-container').innerHTML = `
    <div class="alert">
      <strong>Error:</strong> ${message}
      <button onclick="fetchGif()">Try Again</button>
    </div>
  `;
}
```

#### Key Takeaways:
1. **Always check `response.ok` or status codes**
2. **Validate the response structure** before using data
3. **Provide user feedback** for both success and error states
4. **Use try/catch** with async/await for cleaner error handling
5. **Log errors** to console for debugging
6. **Implement retry logic** for temporary failures

#### Advanced Tips:
- Add timeout handling with `AbortController`
- Implement request retries for 5xx errors
- Use error boundaries in React applications
- Track errors with monitoring tools (Sentry, etc.)

---

# ==Secure authentication keys

